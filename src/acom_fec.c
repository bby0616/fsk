#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#include "acom_fec.h"
#include "crc16.h"

char acom_fec_version[20] = "20211008_1501";

/** state table for the G = (13,15) */
int nextstate[8][2] = {0,4,4,0,5,1,1,5,2,6,6,2,7,3,3,7};
int prestate[8][2] = {0,1,3,2,4,5,7,6,1,0,2,3,5,4,6,7};
int out[8][2] = {0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,1};

/* generated by m serial with fb = 2011(octal)*/
unsigned char scramblebits[80] = {0x9d,0x38,0xde,0x95,0xd2,0xa3,0xbf,0xa0,\
                                  0x5e,0xd5,0x87,0x48,0xcb,0x59,0xeb,0x19,\
                                  0xf9,0x54,0xcc,0xa7,0xd3,0x84,0x6c,0x8a,\
                                  0x6f,0x75,0x73,0x3b,0xb9,0xd4,0xe8,0x3d,\
                                  0xb8,0x62,0x52,0xcd,0x11,0x69,0x74,0xc5,\
                                  0x81,0x49,0x7d,0xe3,0x1b,0xb0,0xf2,0x72,\
                                  0xc4,0x37,0xf3,0x8d,0x4a,0x10,0x96,0xfa,\
                                  0xe2,0xe4,0x3e,0xd5,0x17,0xb3,0x9f,0x07,\
                                  0x25,0x65,0xe5,0xc1,0x5b,0x30,0xd6,0xe8,\
                                  0xaf,0xd1,0xcd,0xca,0x34,0x0c,0x91,0x04};

unsigned short hadamard[16] = {0x0000,0x5555,0x3333,0x6666,0x0f0f,0x5a5a,0x3c3c,0x6969,\
                               0x00ff,0x55aa,0x33cc,0x6699,0x0ff0,0x5aa5,0x3cc3,0x6996};

int debug;


static double logsum(double a,double b){
    double m,f;
    m = (a >= b) ? a : b;
    f = exp(-fabs(a-b));
    return m+log(1+f);
}

static int calc_distance(unsigned short a,unsigned short b){
    unsigned short tmp;
    int count = 0;
    tmp = a ^ b;
    while(tmp){
        tmp = tmp & (tmp - 1);
        count++;
    }
    return count;
}

static int maphadamard(unsigned short temp,unsigned short *hadamard){
    int distance = 16;
    int index = 0;
    int i;
    for(i = 0;i < 16;i++){
        if(distance > calc_distance(temp,hadamard[i])){
            distance = calc_distance(temp,hadamard[i]);
            index = i;
        }
    }
    return index;
}

static void demap8fsk(int length,int (*soft_in)[8],double (*demapsoft_in)[3]){
    int i;
    int a,b,c,d,e,f;
    for(i = 0;i < length;i++){
        a = soft_in[i][0] + soft_in[i][1] + soft_in[i][2] + soft_in[i][3];
        b = soft_in[i][4] + soft_in[i][5] + soft_in[i][6] + soft_in[i][7];
        c = soft_in[i][0] + soft_in[i][1] + soft_in[i][4] + soft_in[i][5];
        d = soft_in[i][2] + soft_in[i][3] + soft_in[i][6] + soft_in[i][7];
        e = soft_in[i][0] + soft_in[i][2] + soft_in[i][4] + soft_in[i][6];
        f = soft_in[i][1] + soft_in[i][3] + soft_in[i][5] + soft_in[i][7];
        demapsoft_in[i][0] = (b-a)/sqrt(b*b+a*a);
        demapsoft_in[i][1] = (d-c)/sqrt(d*d+c*c);
        demapsoft_in[i][2] = (f-e)/sqrt(f*f+e*e);
    }
}

void logmap(int length,double* Le,double *Lout,double *x_n,double *p_n){
    
    int statelen = 8;
    double gamma[length][statelen][2];
    double alpha[length+1][statelen];
    double beta[length+1][statelen];
    double PR1,PR0;
    double x0 = -1.0,x1 = 1.0;
    double p0,p1;
    double infinity = 1e6;
	double alphasum[length+1];
    int i,j;
    double inibeta = -log(statelen);
	
    //initial
    alpha[0][0] = 0.0;
    for(i = 1;i < statelen;i++){
        alpha[0][i] = -infinity;
    }
    for(i = 0;i < statelen;i++){
        beta[length][i] = inibeta; //without termination
    }
	alphasum[0] = 0.0;

    //calc gamma
    for(i = 0;i < length;i++){
        for(j = 0;j < statelen;j++){
			p0 = out[j][0] ? 1.0 : -1.0;
            p1 = out[j][1] ? 1.0 : -1.0;
            gamma[i][j][0] = 0.5*x0*(Le[i]+x_n[i])+0.5*p_n[i]*p0;
            gamma[i][j][1] = 0.5*x1*(Le[i]+x_n[i])+0.5*p_n[i]*p1;
        }
    }  
	//calc alpha
	for(i = 1;i <= length;i++){
		for(j = 0;j < statelen;j++){
			alpha[i][j] = logsum(alpha[i-1][prestate[j][0]]+gamma[i-1][prestate[j][0]][0],alpha[i-1][prestate[j][1]]+gamma[i-1][prestate[j][1]][1]);
			if(alpha[i][j] > alphasum[i-1]){
				alphasum[i] = alpha[i][j];
			}
		}
		for(j = 0; j < statelen;j++){
			alpha[i][j] -= alphasum[i-1];
		}
		
	}
	//calc beta
	for(i = length-1;i >= 0;i--){
		for(j = 0;j < statelen;j++){
			beta[i][j] = logsum(beta[i+1][nextstate[j][0]]+gamma[i][j][0],beta[i+1][nextstate[j][1]]+gamma[i][j][1]);
		}
		for(j = 0;j < statelen;j++){
			beta[i][j] -= alphasum[i];
		}
	} 

	for(i = 0;i < length;i++){
        PR1 = -infinity;
		PR0 = -infinity;
        for(j = 0;j < statelen;j++){
            PR0 = logsum(PR0,alpha[i][j]+gamma[i][j][0]+beta[i+1][nextstate[j][0]]);
            PR1 = logsum(PR1,alpha[i][j]+gamma[i][j][1]+beta[i+1][nextstate[j][1]]);
        }
        Lout[i] = PR1-PR0;
 		if(Lout[i] < -infinity){
			Lout[i] = -infinity;
		}
    }
	
}

void logmap_4fsk(int length,double* Le,double *Lout,int (*y_n)[4]){
    
    int statelen = 8;
    double gamma[length][statelen][2];
    double alpha[length+1][statelen];
    double beta[length+1][statelen];
    double PR1,PR0;
    double x0 = -1.0,x1 = 1.0;
    double infinity = 1e6;
	double alphasum[length+1];
    double inibeta = -log(statelen);

    int i,j;

    //initial
    alpha[0][0] = 0.0;
    for(i = 1;i < statelen;i++){
        alpha[0][i] = -infinity;
    }
    for(i = 0;i < statelen;i++){
        beta[length][i] = inibeta; //without termination
    }
	alphasum[0] = 0.0;

    //calc gamma
    for(i = 0;i < length;i++){
        for(j = 0;j < statelen;j++){
            gamma[i][j][0] = 0.5*x0*Le[i]+y_n[i][out[j][0]];
            gamma[i][j][1] = 0.5*x1*Le[i]+y_n[i][2+out[j][1]];
        }
    }  
	//calc alpha
	for(i = 1;i <= length;i++){
		for(j = 0;j < statelen;j++){
			alpha[i][j] = logsum(alpha[i-1][prestate[j][0]]+gamma[i-1][prestate[j][0]][0],alpha[i-1][prestate[j][1]]+gamma[i-1][prestate[j][1]][1]);
			if(alpha[i][j] > alphasum[i-1]){
				alphasum[i] = alpha[i][j];
			}
		}
		for(j = 0; j < statelen;j++){
			alpha[i][j] -= alphasum[i-1];
		}
		
	}
	//calc beta
	for(i = length-1;i >= 0;i--){
		for(j = 0;j < statelen;j++){
			beta[i][j] = logsum(beta[i+1][nextstate[j][0]]+gamma[i][j][0],beta[i+1][nextstate[j][1]]+gamma[i][j][1]);
		}
		for(j = 0;j < statelen;j++){
			beta[i][j] -= alphasum[i];
		}
	} 

	for(i = 0;i < length;i++){
        PR1 = -infinity;
		PR0 = -infinity;
        for(j = 0;j < statelen;j++){
            PR0 = logsum(PR0,alpha[i][j]+gamma[i][j][0]+beta[i+1][nextstate[j][0]]);
            PR1 = logsum(PR1,alpha[i][j]+gamma[i][j][1]+beta[i+1][nextstate[j][1]]);
        }
        Lout[i] = PR1-PR0;
 		if(Lout[i] < -infinity){
			Lout[i] = -infinity;
		}
    }
	
}

void descramble(unsigned char *infobits,unsigned char *scrambler,unsigned char *originalbits,int bit_num){
    int i,j;
    unsigned char info[bit_num/8];
    unsigned char descramble_info[bit_num/8];
    for(i = 0;i < bit_num/8;i++){
        info[i] = 0;
        descramble_info[i] = 0;
    }

    for(i = 0;i < bit_num/8;i++){
        for(j = 7;j >= 0;j--){
            info[i] |= infobits[8*i+7-j] << j;
        }
    }
    for(i = 0;i < bit_num/8;i++){
        descramble_info[i] = info[i] ^ scramblebits[i];
    }
    for(i = 0;i < bit_num/8;i++){
        for(j = 0;j < 8;j++){
            originalbits[8*i+j] = (descramble_info[i] >> (7-j)) & 1;
        }
    }
}

void RSC(int bit_cnt,unsigned char* codein,unsigned char* codeout){
    int i;
    int state = 0;
    for(i = 0;i < bit_cnt;i++){
        if(*(codein+i) == 0){
            *(codeout+i) = out[state][0];
            state = nextstate[state][0];
        }
        else if(*(codein+i) == 1){
            *(codeout+i) = out[state][1];
            state = nextstate[state][1];
        }
    }
}

void permutation(int* a,int length){
    int f1,f2,i;
    if(length == 256){
        f1 = 15;
        f2 = 32;
    }else if(length == 384){
        f1 = 23;
        f2 = 48;
    }else if(length == 640){
        f1 = 39;
        f2 = 80;
    }else if(length == 320){
        f1 = 21;
        f2 = 120;
    }else{
        printf("Can't permutate!!The packet length %d is not supported.",length);
    }
    for(i = 0;i < length;i++){
		a[i] = f1*i + f2*i*i;
		a[i] = a[i] % length;
    }
}

void scramble(str_Packet *pkt,unsigned char *scrambler, unsigned char *infobits,int bit_num){
    int i,j;
    unsigned char *temp;
    temp = (unsigned char *)pkt;
    unsigned char tempbits[bit_num/8];

    for(i = 0;i < bit_num/8;i++){
        tempbits[i] = temp[i] ^ scramblebits[i];
    }

    for(i = 0;i < bit_num/8;i++){
        for(j = 0;j < 8;j++){
            infobits[8*i+j] = (tempbits[i] >> (7-j)) & 1;
        }
    }
}

void acom_fec_8fsk(int (*soft_in)[8],int sym_cnt,str_Macinfo *macinfo){
/**
 * acom_fec_8fsk - use the soft infomation to decode
 * @soft_in: input received 8fsk soft infomation
 * @macinfo: input member variables hdrlength and pktlength, and 
 * output other variables which is acquired according to the decoding result
 *
 **/
    // int sym_cnt = macinfo->hdrlength + macinfo->dtlength;
    macinfo->hdrlength = 128;
    macinfo->dtlength = 256;
    double Le1[sym_cnt];
    double Le1_permuted[sym_cnt];
    double Le2[sym_cnt];
    double Le2_permuted[sym_cnt];
    double Lout[sym_cnt];
    unsigned char infobits[sym_cnt];
    unsigned char oringinalbits[sym_cnt];
    unsigned char oringinalbytes[sym_cnt/8];
	int i,j,iter;
    unsigned short crc_calc,crc_receive;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;

    int p[sym_cnt];
    int tempy[sym_cnt][8];
    double demapinfo[sym_cnt][3];
    double ys[sym_cnt];
    double ys_permuted[sym_cnt];
    double yp1[sym_cnt];
    double yp2[sym_cnt];

    readcfg();

    permutation(p,sym_cnt);
    
    for(i = 0;i < sym_cnt;i++){
        for(j = 0;j < 8;j++){
            tempy[p[i]][j] = soft_in[i][j];
        }
    }

    demap8fsk(sym_cnt,tempy,demapinfo);

    for(i = 0;i < sym_cnt;i++){
        ys[i] = demapinfo[i][0];
        yp1[i] = demapinfo[i][1];
        yp2[i] = demapinfo[i][2];
        ys_permuted[i] = demapinfo[p[i]][0];
    }


    //decode
    for(i = 0;i < sym_cnt;i++){
        Le2[i] = 0;
    }
    for(iter = 0;iter < 8;iter++){
        logmap(sym_cnt,Le2,Lout,ys,yp1);
        for(i = 0;i < sym_cnt;i++){
            Le1[i] = Lout[i] - Le2[i] - ys[i];
        }
        for(i = 0;i < sym_cnt;i++){
            Le1_permuted[i] = Le1[p[i]];
        }
        logmap(sym_cnt,Le1_permuted,Lout,ys_permuted,yp2);
        for(i = 0;i < sym_cnt;i++){
            Le2_permuted[i] = Lout[i] - Le1_permuted[i] - ys_permuted[i];
        }
        for(i = 0;i < sym_cnt;i++){
            Le2[p[i]] = Le2_permuted[i];
        }
    }

    if(debug){
        printf("(DEBUG)LLR:\n");
        for(i = 0;i < sym_cnt;i++){
            printf("%10lf ",Le1[i]);
            if((i+1)%16 == 0){
                printf("\n");
            }
        }
    }
    
    //decision
    for(i = 0;i < sym_cnt;i++){
        infobits[i] = (Le2[i]+Le1[i]+ys[i] > 0) ? 1 : 0;
    }

    descramble(infobits,scramblebits,oringinalbits,sym_cnt);

    for(i = 0;i < sym_cnt/8;i++){
        oringinalbytes[i] = 0;
    }
    for(i = 0;i < sym_cnt/8;i++){
        for(j = 7;j >= 0;j--){
            oringinalbytes[i] |= oringinalbits[8*i+7-j] << j;
        }
    }

    str_Packet *pkt = (str_Packet *)oringinalbytes;
    macinfo->dst = maphadamard(pkt->hdr_mac.dst_addr,hadamard);
    macinfo->src = maphadamard(pkt->hdr_mac.src_addr,hadamard);
    macinfo->via = maphadamard(pkt->hdr_mac.via_addr,hadamard);

    crc_calc = crc16(0,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    crc_receive = pkt->hdr_mac.crc16;
    if( crc_calc != crc_receive){
        macinfo->op_code = 0;
    }
    else{
        macinfo->op_code = 1;
    }

    if(debug){
        printf("(DEBUG)crc_calc:%04x,crc_receive:%04x\n",crc_calc,crc_receive);
    }

    macinfo->ttl = maphadamard(pkt->hdr_mac.ttl,hadamard);
	for(i = 0;i < macinfo->dtlength;i++){
        if(*(pkt->payload_data+hdrbytes-10+i) > 0 && *(pkt->payload_data+hdrbytes-10+i) < 32 || *(pkt->payload_data+hdrbytes-10+i) > 126){
            *(pkt->payload_data+hdrbytes-10+i) = 32;
        }
    }
    memcpy(macinfo->data,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    macinfo->data[dtbytes] = 0;

}

void acom_enc_8fsk(str_Macinfo *macinfo,int *sym_cnt,unsigned char *enc_out){
/**
 * acom_enc_8fsk - generate packet and encode 
 * @macinfo: input the raw infomation which will be encoded 
 * @symcnt: output the symbol count
 * @enc_out: output the 8fsk encode result
 *
 **/
    macinfo->dtlength = 256;
    macinfo->hdrlength = 128;
    int i;
    int packetlength = macinfo->hdrlength + macinfo->dtlength;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;
    unsigned char infobits[packetlength];
    unsigned char permutated_infobits[packetlength];
    unsigned char rsccode[packetlength];
    unsigned char peinforsccode[packetlength];
    unsigned char info_8fsk[packetlength];
    int p[packetlength];
    unsigned char temp[packetlength];

    str_Packet *packet;
    packet = (str_Packet *)malloc(sizeof(str_Packet));

    readcfg();

    *sym_cnt = macinfo->hdrlength + macinfo->dtlength;

    packet->hdr_mac.dst_addr = hadamard[macinfo->dst];
    packet->hdr_mac.src_addr = hadamard[macinfo->src];
    packet->hdr_mac.via_addr = hadamard[macinfo->via];
    packet->hdr_mac.ttl = hadamard[macinfo->ttl & 0xf];
    memcpy(packet->payload_data+hdrbytes-10,macinfo->data,dtbytes*sizeof(char));
    packet->hdr_mac.crc16 = crc16(0,packet->payload_data+hdrbytes-10,dtbytes);
    
    scramble(packet,scramblebits,infobits,packetlength);

    permutation(p,packetlength);

    for(i = 0;i <packetlength;i++){
        permutated_infobits[i] = infobits[p[i]];
    }

    RSC(packetlength,infobits,rsccode); 
    RSC(packetlength,permutated_infobits,peinforsccode);

    for(i = 0;i < packetlength;i++){
        info_8fsk[i] = infobits[i]*4 + rsccode[i]*2 + peinforsccode[i];
    }

   

    for(i = 0;i < packetlength;i++){
        temp[i] = info_8fsk[i];
    }

    for(i = 0;i < packetlength;i++){
        info_8fsk[i] = temp[p[i]];
    }

    if(debug){
        printf("(DEBUG)encoded 8fsk infomation:");
        for(i = 0;i < packetlength;i++){
            printf("%d ",info_8fsk[i]);
        }
        printf("\n");
    }
    

    for ( i = 0; i < packetlength/2; i++)
    {
        enc_out[i] = (info_8fsk[2*i] & 0xf) + (info_8fsk[2*i+1] << 4);
    }

    free(packet);
}

void acom_fec_4fsk(int (*soft_in)[4],int sym_cnt,str_Macinfo *macinfo){
/**
 * acom_fec_4fsk - use the soft infomation to decode
 * @soft_in: input received 8fsk soft infomation
 * @macinfo: input member variables hdrlength and pktlength, and 
 * output other variables which is acquired according to the decoding result
 *
 **/
    // int sym_cnt = macinfo->hdrlength + macinfo->dtlength;
    macinfo->hdrlength = 128;
    macinfo->dtlength = 256;
    double Le[sym_cnt];
    double Lout[sym_cnt];
    unsigned char infobits[sym_cnt];
    unsigned char oringinalbits[sym_cnt];
    unsigned char oringinalbytes[sym_cnt/8];
	int i,j,iter;
    unsigned short crc_calc,crc_receive;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;

    int p[sym_cnt];
    int tempy[sym_cnt][4];

    readcfg();

    permutation(p,sym_cnt);
    
    for(i = 0;i < sym_cnt;i++){
        for(j = 0;j < 4;j++){
            tempy[p[i]][j] = soft_in[i][j];
        }
    }

    //decode
    for(i = 0;i < sym_cnt;i++){
        Le[i] = 0;
    }
    
    logmap_4fsk(sym_cnt,Le,Lout,tempy);

    for(i = 0;i < sym_cnt;i++){
        infobits[i]   = (Lout[i] > 0) ? 1 : 0;
    }


    if(debug){
        printf("(DEBUG)LLR:\n");
        for(i = 0;i < sym_cnt;i++){
            printf("%10lf ",Le[i]);
            if((i+1)%16 == 0){
                printf("\n");
            }
        }
        // printf("\n");
    }

    descramble(infobits,scramblebits,oringinalbits,sym_cnt);

    for(i = 0;i < sym_cnt/8;i++){
        oringinalbytes[i] = 0;
    }
    for(i = 0;i < sym_cnt/8;i++){
        for(j = 7;j >= 0;j--){
            oringinalbytes[i] |= oringinalbits[8*i+7-j] << j;
        }
    }

    str_Packet *pkt = (str_Packet *)oringinalbytes;
    macinfo->dst = maphadamard(pkt->hdr_mac.dst_addr,hadamard);
    macinfo->src = maphadamard(pkt->hdr_mac.src_addr,hadamard);
    macinfo->via = maphadamard(pkt->hdr_mac.via_addr,hadamard);

    crc_calc = crc16(0,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    crc_receive = pkt->hdr_mac.crc16;
    if( crc_calc != crc_receive){
        macinfo->op_code = 0;
    }
    else{
        macinfo->op_code = 1;
    }

    if(debug){
        printf("(DEBUG)crc_calc:%04x,crc_receive:%04x\n",crc_calc,crc_receive);
    }

    macinfo->ttl = maphadamard(pkt->hdr_mac.ttl,hadamard);
	for(i = 0;i < macinfo->dtlength;i++){
        if(*(pkt->payload_data+hdrbytes-10+i) > 0 && *(pkt->payload_data+hdrbytes-10+i) < 32 || *(pkt->payload_data+hdrbytes-10+i) > 126){
            *(pkt->payload_data+hdrbytes-10+i) = 32;
        }
    }
    memcpy(macinfo->data,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    macinfo->data[dtbytes] = 0;

}

//str_Macinfo address info
void acom_enc_4fsk(str_Macinfo *macinfo,int *sym_cnt,unsigned char *enc_out){
/**
 * acom_enc_8fsk - generate packet and encode 
 * @macinfo: input the raw infomation which will be encoded 
 * @symcnt: output the symbol count
 * @enc_out: output the 8fsk encode result
 *
 **/
    macinfo->dtlength = 256; //data length
    macinfo->hdrlength = 128; //header length
    int i;
    int packetlength = macinfo->hdrlength + macinfo->dtlength;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;
    unsigned char infobits[packetlength];
    unsigned char permutated_infobits[packetlength];
    unsigned char rsccode[packetlength];
    unsigned char peinforsccode[packetlength];
    unsigned char info_4fsk[packetlength];
    int p[packetlength];
    unsigned char temp[packetlength];

    str_Packet *packet;
    packet = (str_Packet *)malloc(sizeof(str_Packet));

    readcfg();

    *sym_cnt = macinfo->hdrlength + macinfo->dtlength;

    packet->hdr_mac.dst_addr = hadamard[macinfo->dst];
    packet->hdr_mac.src_addr = hadamard[macinfo->src];
    packet->hdr_mac.via_addr = hadamard[macinfo->via];
    packet->hdr_mac.ttl = hadamard[macinfo->ttl & 0xf];
    memcpy(packet->payload_data+hdrbytes-10,macinfo->data,dtbytes*sizeof(char));
    packet->hdr_mac.crc16 = crc16(0,packet->payload_data+hdrbytes-10,dtbytes);
    
    scramble(packet,scramblebits,infobits,packetlength);

    permutation(p,packetlength);

    RSC(packetlength,infobits,rsccode); 

    for(i = 0;i < packetlength;i++){
        info_4fsk[i] = infobits[i]*2 + rsccode[i];
    }

    for(i = 0;i < packetlength;i++){
        temp[i] = info_4fsk[i];
    }

    for(i = 0;i < packetlength;i++){
        info_4fsk[i] = temp[p[i]];
    }

    if(debug){
        printf("(DEBUG)encoded 8fsk infomation:");
        for(i = 0;i < packetlength;i++){
            printf("%d ",info_4fsk[i]);
        }
        printf("\n");
    }
    

    for ( i = 0; i < packetlength/2; i++)
    {
        enc_out[i] = (info_4fsk[2*i] & 0xf) + (info_4fsk[2*i+1] << 4);
    }

    free(packet);
}

void acom_fec_8fsk_half(int (*soft_in)[8],int sym_cnt,str_Macinfo *macinfo){
/**
 * acom_fec_8fsk_half - use the soft infomation to decode
 * @soft_in: input received 8fsk soft infomation
 * @macinfo: input member variables hdrlength and pktlength, and 
 * output other variables which is acquired according to the decoding result
 *
 **/
    
    macinfo->hdrlength = 128;
    macinfo->dtlength = 256;
    int bit_cnt = macinfo->hdrlength + macinfo->dtlength;
    double Le[bit_cnt];
    double Lout[bit_cnt];
    unsigned char infobits[bit_cnt];
    unsigned char oringinalbits[bit_cnt];
    unsigned char oringinalbytes[bit_cnt/8];
	int i,j,iter;
    unsigned short crc_calc,crc_receive;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;

    int p[sym_cnt];
    int tempy[sym_cnt][8];
    double demapinfo[sym_cnt][3];
    double ys[bit_cnt];
    double yp[bit_cnt];

    readcfg();

    permutation(p,sym_cnt);
    
    for(i = 0;i < sym_cnt;i++){
        for(j = 0;j < 8;j++){
            tempy[p[i]][j] = soft_in[i][j];
        }
    }

    demap8fsk(sym_cnt,tempy,demapinfo);

    j = 0;
    for(i = 0;i < bit_cnt;i += 3){
        ys[i] = demapinfo[j][0];
        yp[i] = demapinfo[j][1];
        ys[i+1] = demapinfo[j][2];
        yp[i+1] = demapinfo[j+1][0];
        ys[i+2] = demapinfo[j+1][1];
        yp[i+2] = demapinfo[j+1][2];
        j += 2;
    }

    //decode
    for(i = 0;i < bit_cnt;i++){
        Le[i] = 0;
    }
    for(iter = 0;iter < 10;iter++){
        logmap(bit_cnt,Le,Lout,ys,yp);
        for(i = 0;i < bit_cnt;i++){
            Le[i] = Lout[i] - Le[i] - ys[i];
        }
    }

    if(debug){
        printf("(DEBUG)LLR:\n");
        for(i = 0;i < bit_cnt;i++){
            printf("%10lf ",Le[i]);
            if((i+1)%16 == 0){
                printf("\n");
            }
        }
        // printf("\n");
    }
    
    //decision
    for(i = 0;i < bit_cnt;i++){
        infobits[i] = (Lout[i] > 0) ? 1 : 0;
    }

    descramble(infobits,scramblebits,oringinalbits,bit_cnt);

    for(i = 0;i < bit_cnt/8;i++){
        oringinalbytes[i] = 0;
    }
    for(i = 0;i < bit_cnt/8;i++){
        for(j = 7;j >= 0;j--){
            oringinalbytes[i] |= oringinalbits[8*i+7-j] << j;
        }
    }

    str_Packet *pkt = (str_Packet *)oringinalbytes;
    macinfo->dst = maphadamard(pkt->hdr_mac.dst_addr,hadamard);
    macinfo->src = maphadamard(pkt->hdr_mac.src_addr,hadamard);
    macinfo->via = maphadamard(pkt->hdr_mac.via_addr,hadamard);

    crc_calc = crc16(0,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    crc_receive = pkt->hdr_mac.crc16;
    if( crc_calc != crc_receive){
        macinfo->op_code = 0;
    }
    else{
        macinfo->op_code = 1;
    }

    if(debug){
        printf("(DEBUG)crc_calc:%04x,crc_receive:%04x\n",crc_calc,crc_receive);
    }

    macinfo->ttl = maphadamard(pkt->hdr_mac.ttl,hadamard);
	for(i = 0;i < macinfo->dtlength;i++){
        if(*(pkt->payload_data+hdrbytes-10+i) > 0 && *(pkt->payload_data+hdrbytes-10+i) < 32 || *(pkt->payload_data+hdrbytes-10+i) > 126){
            *(pkt->payload_data+hdrbytes-10+i) = 32;
        }
    }
    memcpy(macinfo->data,pkt->payload_data+hdrbytes-10,dtbytes*sizeof(char));
    macinfo->data[dtbytes] = 0;

}

void acom_enc_8fsk_half(str_Macinfo *macinfo,int *sym_cnt,unsigned char *enc_out){
/**
 * acom_enc_8fsk - generate packet and encode 
 * @macinfo: input the raw infomation which will be encoded 
 * @symcnt: output the symbol count
 * @enc_out: output the 8fsk encode result
 *
 **/
    macinfo->dtlength = 256;
    macinfo->hdrlength = 128;
    int i,j;
    int packetlength = macinfo->hdrlength + macinfo->dtlength;
    // int infolength = packetlength/3*2;
    int infolength = 256;
    int hdrbytes = macinfo->hdrlength / 8;
    int dtbytes = macinfo->dtlength / 8;
    unsigned char infobits[packetlength];
    unsigned char rsccode[packetlength];
    unsigned char info_8fsk[infolength];
    int p[infolength];
    unsigned char temp[infolength];

    str_Packet *packet;
    packet = (str_Packet *)malloc(sizeof(str_Packet));

    readcfg();

    *sym_cnt = infolength;

    packet->hdr_mac.dst_addr = hadamard[macinfo->dst];
    packet->hdr_mac.src_addr = hadamard[macinfo->src];
    packet->hdr_mac.via_addr = hadamard[macinfo->via];
    packet->hdr_mac.ttl = hadamard[macinfo->ttl & 0xf];
    memcpy(packet->payload_data+hdrbytes-10,macinfo->data,dtbytes*sizeof(char));
    packet->hdr_mac.crc16 = crc16(0,packet->payload_data+hdrbytes-10,dtbytes);
    
    scramble(packet,scramblebits,infobits,packetlength);

    permutation(p,infolength);

    RSC(packetlength,infobits,rsccode); 
    j = 0;
    for(i = 0;i < infolength;i += 2){
        info_8fsk[i] = infobits[j]*4 + rsccode[j]*2 + infobits[j+1];
        info_8fsk[i+1] = rsccode[j+1]*4 + infobits[j+2]*2 + rsccode[j+2];
        j += 3;
    }

    for(i = 0;i < infolength;i++){
        temp[i] = info_8fsk[i];
    }

    for(i = 0;i < infolength;i++){
        info_8fsk[i] = temp[p[i]];
    }

    if(debug){
        printf("(DEBUG)encoded 8fsk infomation:");
        for(i = 0;i < infolength;i++){
            printf("%d ",info_8fsk[i]);
        }
        printf("\n");
    }
    

    for ( i = 0; i < infolength/2; i++)
    {
        enc_out[i] = (info_8fsk[2*i] & 0xf) + (info_8fsk[2*i+1] << 4);
    }

    free(packet);
}


void readcfg(void){
    char buf[100];
    char *p;
    FILE *fp;
    if((fp = fopen("debug.cfg","r")) == NULL){
        // printf("Can't open config file!Debug mode set off!\n");
        debug = 0;
        return;
    }
    fgets(buf,100,fp);
    while(!feof(fp)){
        while(buf[0] == '#'){
            fgets(buf,100,fp);
        }
        p = strstr(buf,"DEBUG");
        if(p == NULL){
            continue;
        }
        p += strlen("DEBUG");
        p = strstr(p,"=");
        if(p == NULL){
            printf("config file is illegal\n");
            continue;
        }
        p += strlen("=");
        debug = p[0] - 48;
    }
    fclose(fp);
}